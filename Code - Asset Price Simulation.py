import numpy as np
import math
import matplotlib.pyplot as plt



def FormulaSetup():                                 # S(t) = S(0) * e^((mu - sigma^2 / 2)*t + sigma * W(t))

    global S_0, mu, sigma
    S_0 = 10                                        # inital value
    mu = 0.1                                        # drift
    sigma = 0.2                                     # volatility

    global T, delta_t, M                            # time index
    T = 2
    delta_t = 0.01
    M = int(T / delta_t)



def RejectionSampling(sample_size):                  # rejection sampling

    def PDF_Std_Normal_Dist(x):                      # probability density function of standard normal distribution, p(x)
        p_x = 1/ math.sqrt(2*math.pi) * math.exp(-x**2/2) 
        return p_x

    a = -5                                           # left endpoint of the interval
    b = 5                                            # right endpoint of the interval
    max_p_x = PDF_Std_Normal_Dist(0)                 # max p(x) in the range [a, b]

    samples = []
    while len(samples) < sample_size:
        x0 = np.random.rand(1) * (b-a) + a           # x0 in the range [a, b] 
        y = np.random.rand(1) * max_p_x              # y in the range [0, max p(x)]
        if y <= PDF_Std_Normal_Dist(x0):
            samples.append(x0)                       # x0 is a sample if y <= p(x0) 

    return samples



def AssetPriceSimulation(S_0, mu, sigma, T, delta_t, M):

    def WernerProcess(W, t, sample_mean):                       # Werner Process W(t) = W(t-1) + sqrt(delta_t) * X   
        return W[t-1] + math.sqrt(delta_t) * sample_mean        # where X is standard normal distributed random variable

    def PriceModel(S_0, mu, sigma, t, W_t):                     # asset price model: S(t) = S(0) * e^((mu - sigma^2 / 2)*t + sigma * W(t))
        return S_0 * math.exp((mu - sigma**2/2)*t + sigma * W_t)

    sample_size = 250

    W = [0]                                                     # Werner Process, W(0) = 0
    S = [S_0]                                                   # asset prices, S(0) = S_0

    for i in range(1, M+1): 
        samples = RejectionSampling(sample_size)                # generate samples
        sample_mean = np.mean(samples)                          # compute sample mean, i.e. unbiased estimator of X

        W_i = WernerProcess(W, i, sample_mean)                  # compute W(t_i)
        S_i = PriceModel(S_0, mu, sigma, delta_t*i, W_i)        # compute S(t_i)

        W.append(W_i)
        S.append(S_i)

    return S



def Plotting():

    x = np.linspace(0, T, M+1)                  # x-coordinates
    y1 = asset_prices1                          # y-coordinates
    y2 = asset_prices2
    y3 = asset_prices3

    plt.plot(x, y1, 'tab:red')                  # plot models
    plt.plot(x, y2, 'tab:blue')
    plt.plot(x, y3, 'tab:green')
    
    plt.xlim(0, 2.05)                          

    plt.xlabel('Time')
    plt.ylabel('Price')
    plt.title('Asset Price Simulation')

    plt.show()



'''

This program is to generate a line chart for the asset price model: S(t) = S(0) * e^((mu - sigma^2 / 2)*t + sigma * W(t))
where S(0) is the initial value, mu is the draft, sigma is the volatility, t is the time and W is Werner Process.

T is the time length , delta_t is the time difference and M = T/delta_t is the number of equidistant points.

Setup: S(0) = 10, mu = 0.1, sigma = 0.2, T = 2, delta_t = 0.01, M = 200


Normal distributed values are generated by rejection samplings 

'''

# Main Programme

FormulaSetup()

asset_prices1 = AssetPriceSimulation(S_0, mu, sigma, T, delta_t, M)
asset_prices2 = AssetPriceSimulation(S_0, mu, sigma, T, delta_t, M)
asset_prices3 = AssetPriceSimulation(S_0, mu, sigma, T, delta_t, M)

Plotting()